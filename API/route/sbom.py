from flask_restx import Namespace, Resource, reqparse
from werkzeug.datastructures import FileStorage
import os
import uuid
import subprocess
from DB import Mongo_Handler

upload_directory = "upload"

def sbom(sqlite_client):
    api = Namespace("sbom", description="SBOM 관련 API")
    
    file_upload = reqparse.RequestParser()
    file_upload.add_argument('file', location='files', type=FileStorage, required=True, help='The file to be uploaded')

    @api.route('/upload', methods=['POST'])
    class SbomUploadFile(Resource):
        @staticmethod
        def ensure_upload_directory_exists():
            """Ensure the upload directory exists."""
            os.makedirs(upload_directory, exist_ok=True)

        @staticmethod
        def save_uploaded_file(uploaded_file):
            """Save the uploaded file in a random directory and return its path."""
            random_dir_name = str(uuid.uuid4())
            directory_path = os.path.join(upload_directory, random_dir_name)
            os.makedirs(directory_path, exist_ok=True)

            file_path = os.path.join(directory_path, uploaded_file.filename)
            uploaded_file.save(file_path)
            return random_dir_name

        @api.expect(file_upload, validate=True)
        def post(self):
            self.ensure_upload_directory_exists()
            
            args = file_upload.parse_args()
            uploaded_file = args['file']
            
            if not uploaded_file:
                return {"error": "No file part"}, 400

            random_dir_name = self.save_uploaded_file(uploaded_file)
            
            return {"result": f"File saved to {random_dir_name}"}, 200
    
    filename_parser = reqparse.RequestParser()
    filename_parser.add_argument('filename', type=str, required=True, help='Name of the SBOM file to be scanned')
    
    @api.route('/scan', methods=['GET'])
    class SbomScan(Resource):
        @staticmethod
        def run_syft_grype(target_directory):
            script_path = "Scripts/sbom_run.sh"

            result = subprocess.run([script_path, target_directory], capture_output=True, text=True)

            return result.returncode
        
        @staticmethod
        def run_result(run_result):
            if run_result == 0:
                return {"result":"success"}, 200
            elif run_result == 1:
                return {"result":"false", "error":"No filename provided"}, 400
            elif run_result == 2:
                return {"result":"false", "error":"Not config file"}, 400
            elif run_result == 3:
                return {"result":"false", "error":"Not SBOM file"}, 400
            
        @staticmethod
        def save(target_directory):
            mongo = Mongo_Handler(target_directory)
            file = os.path.join(target_directory, "vuln_list.json")
            
            
            collection_name = file.split("/")[1]
            result = mongo.grype_save(collection_name, file)            
            
            return result
                
        @api.doc(
            params={"filename": {"description": "SBOM File", "in": "query", "type": "string"}},
            responses={200: "Success"},
            description="업로드한 파일을 Syft랑 Grype에 돌리는 기능",
        )
        def get(self):      
            args = filename_parser.parse_args()
            random_dir_name = args["filename"]

            # Check if the directory exists in the upload directory
            directory_path = os.path.join(upload_directory, random_dir_name)
            if not os.path.exists(directory_path) or not os.path.isdir(directory_path):
                return {"error": f"Directory {random_dir_name} not found"}, 404

            result = SbomScan.run_result(
                SbomScan.run_syft_grype(directory_path)
            )
            
            SbomScan.save(directory_path)
            
            return result
    
    parser = reqparse.RequestParser()
    parser.add_argument('resultID', type=str, required=True, help='Result ID of the scanned SBOM file', location='args')
    
    @api.route('/result', methods=['GET'])
    class SbomResult(Resource):       
        def check_cve(self, cve_id):
            if cve_id.startswith("CVE"):
                return True
            else:
                return False
            
        def get_poc_link(self, cve_id):
            check_result = self.check_cve(cve_id)
            if check_result:
                cursor = sqlite_client.cursor()
                cursor.execute("""
                        SELECT poc_name, html_url
                        FROM PoC
                        WHERE cve_id = ?
                    """, 
                    (cve_id,)
                )
                poc_infos = cursor.fetchall()
                cursor.close()
                
                if not poc_infos:
                    return None
            
                results = {}
                for poc_name, poc_link in poc_infos:
                    results[poc_name] = poc_link
                    
                return results
        
        @api.doc(
            params={"resultID": {"description": "Result ID", "in": "query", "type": "string"}},
            responses={200: "Success"},
            description="Fetches the vulnerability data based on the result ID",
        )
        def get(self):
            args = parser.parse_args()
            reuslt_id = args["resultID"]
            
            # Assuming you have a method in Mongo_Handler to fetch the vulnerability data
            mongo_handler = Mongo_Handler(json_path="./poc")
            vuln_data = mongo_handler.db[f"{reuslt_id}"].find()
            
            results = {}
            for doc in vuln_data:
                for match in doc["matches"]:
                    package_name = match["artifact"]["name"]
                    package_type = match["artifact"]["type"]
                    
                    github_vuln_id = match["vulnerability"]["id"]
                    github_severity = match["vulnerability"]["severity"]
                    
                    # relatedVulnerabilities의 각 항목에 대해 CVE 정보 추출
                    for related_vuln in match.get("relatedVulnerabilities", []):
                        cve_id = related_vuln.get("id")
                        cve_severity = related_vuln.get("severity")
                        
                        # 결과 딕셔너리에 CVE 정보 추가
                        if package_name not in results:
                            results[package_name] = {
                                "type": package_type,
                                "vulnerability": {},
                                "cve": {},
                                "github": {}
                            }
                        
                        if cve_id:
                            poc_link = self.get_poc_link(cve_id)
                            cve_info = {  # cve_info를 여기에서 정의
                                "severity": cve_severity
                            }
                            if poc_link:
                                cve_info["PoC Link"] = poc_link
                            results[package_name]["cve"][cve_id] = cve_info  # 여기에서 cve_info 사용
                            
                    # github 정보 추가
                    if "github" not in results[package_name]:
                        results[package_name]["github"] = {}
                    
                    if github_vuln_id:
                        results[package_name]["github"][github_vuln_id] = {
                            "severity": github_severity,
                        }

            return {'results': results}, 200


    return api
