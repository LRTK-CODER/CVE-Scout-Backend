from flask_restx import Namespace, Resource, reqparse
from flask import request, jsonify
import openai
import os

openai.api_key = os.getenv('CHATGPT_API')

def gpt(sqlite_client, mongo_handler):
    api = Namespace('gpt', description='ChatGPT 관련 라우트')
    
    @api.route('/test')
    class TEST(Resource):
        @api.doc(
            responses={200: "Success"},
            description="ChatGPT에 'log4shell' 취약점에 대해 물어보고 응답 받기"
        )
        def get(self):
            text = "CVE-2021-44228에 대해서 설명해줘"

            response = openai.ChatCompletion.create(
                model="gpt-3.5-turbo-0613",
                messages=[
                    {"role": "system", "content": "You are a helpful assistant."},
                    {"role": "user", "content": text},
                ]
            )

            return {"response": response['choices'][0]['message']['content'].strip()}, 200

    def get_cve_mitigation_plan(cve_info):
        plan_content = f"""
            [CVE 정보] 
            {cve_info[0]}
            
            [취약점 설명]
            {cve_info[1]} 
            
            [CVSS정보]
            {cve_info[2]}

            위 취약점에 대한 조치방안을 다음과 같은 형식으로 요약해줘.
            이때 버전 업그레이드의 조치방안은 빼줘 그리고 조치방안은 5개 이하로 알려줘

            [조치 방안]
            1. ~~~~
            2. ~~~~
            3. ~~~~
            4. ~~~~
            5. ~~~~
        """

        plan_response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "You are an information security expert who speaks Korean."},
                {"role": "user", "content": plan_content},
            ]
        )
        
        return plan_response['choices'][0]['message']['content'].strip()
    
    def translate_vulnerability_description(cve_description):
        translation_request_content = f"""
            {cve_description}

            취약점 설명에 대해서 한국어로 번역해줘.
            이때 전문용어는 번역하지 말고 그대로 사용해줘.
        """
        
        translation_response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "You are an information security expert who speaks Korean."},
                {"role": "user", "content": translation_request_content},
            ]
        )
        
        return translation_response['choices'][0]['message']['content'].strip()
    
    def get_namespace_pattern(cve_id):
        if cve_id.startswith("GHSA"):
            return "github:%"
        elif cve_id.startswith("CVE"):
            return "nvd:%"
        else:
            return None
        
    def vunlerability_db_parsing(cve_id):
        namespace_pattern = get_namespace_pattern(cve_id)
        if namespace_pattern is None:
            return {"error": "지원하지 않는 취약점 ID 형식입니다."}, 400
        
        cursor = sqlite_client.cursor()
        cursor.execute("""
                SELECT id, description, cvss, severity
                FROM vulnerability_metadata
                WHERE id = ? AND namespace LIKE ?
            """, 
            (cve_id, namespace_pattern)
        )
        cve_info = cursor.fetchone()
        cursor.close()
        
        return cve_info
    
    @api.route('/report/<cve_id>')
    class singleVulnerabilityMitigation(Resource):
        @api.doc(
            responses={200: "Success", 404: "not found"},
            description="ChatGPT에 취약점 정보를 바탕으로 조치 방안 요청"
        )
        def get(self, cve_id): 
            cve_info = vunlerability_db_parsing(cve_id)

            if not cve_info:
                return {"error": "CVE 정보를 찾을 수 없습니다."}, 404

            mitigation_plan = get_cve_mitigation_plan(cve_info)
            translated_description = translate_vulnerability_description(cve_info[1])
            
            return {
                "response": {
                    "id": cve_info[0],
                    "description": translated_description,
                    "severity": cve_info[3],
                    "CVSS_info": cve_info[2],
                    "mitigation_plan": mitigation_plan
                }
            }, 200
    
    parser = reqparse.RequestParser()
    parser.add_argument('resultID', type=str, required=True, help='Result ID of the scanned SBOM file', location='args')
    
    @api.route('/report/all')
    class multiVulnerabilityMitigation(Resource):
        def cve_data_processing(self, cve_id):
            cve_info = vunlerability_db_parsing(cve_id)
            if not cve_info:
                return "CVE 정보가 없습니다."
            
            mitigation_plan = get_cve_mitigation_plan(cve_info)
            translated_description = translate_vulnerability_description(cve_info[1])

            return {
                "id": cve_info[0],
                "description": translated_description,
                "severity": cve_info[3],
                "CVSS_info": cve_info[2],
                "mitigation_plan": mitigation_plan
            }
            
        def mongoDB_data_processing(self, vuln_data):
            results = {}
            for doc in vuln_data:
                for match in doc["matches"]:
                    package_name = match["artifact"]["name"]
                    package_type = match["artifact"]["type"]
                    vuln_id = match["vulnerability"]["id"]
                    
                    if package_name not in results:
                        results[package_name] = {
                            "type": package_type,
                            "vulnerability": {}
                        }

                    results[package_name]["vulnerability"][vuln_id] = self.cve_data_processing(vuln_id)
                    
            return results
        
        @api.doc(
            responses={200: "Success", 404: "not found"},
            params={"resultID": {"description": "Result ID", "in": "query", "type": "string"}},
            description="ChatGPT에 CVE 정보를 바탕으로 조치 방안 요청"
        )
        def get(self): 
            args = parser.parse_args()
            reuslt_id = args["resultID"]
            
            vuln_data = mongo_handler.db[f"{reuslt_id}"].find()
            results = self.mongoDB_data_processing(vuln_data)
            
            return results, 200
        
    return api