from flask_restx import Namespace, Resource, reqparse, fields
from flask import request, jsonify, send_file, after_this_request
import openai
import os
from docx import Document
from docx.shared import Pt, Inches
from docx.enum.text import WD_ALIGN_PARAGRAPH
import shutil

openai.api_key = os.getenv('CHATGPT_API')

def gpt(sqlite_client, mongo_handler):
    api = Namespace('gpt', description='ChatGPT 관련 라우트')
    
    @api.route('/test')
    class TEST(Resource):
        @api.doc(
            responses={200: "Success"},
            description="ChatGPT에 'log4shell' 취약점에 대해 물어보고 응답 받기"
        )
        def get(self):
            text = "CVE-2021-44228에 대해서 설명해줘"

            response = openai.ChatCompletion.create(
                model="gpt-3.5-turbo-0613",
                messages=[
                    {"role": "system", "content": "You are a helpful assistant."},
                    {"role": "user", "content": text},
                ]
            )

            return {"response": response['choices'][0]['message']['content'].strip()}, 200

    def get_cve_mitigation_plan(cve_info):
        plan_content = f"""
            [CVE 정보] 
            {cve_info[0]}
            
            [취약점 설명]
            {cve_info[1]} 
            
            [CVSS정보]
            {cve_info[2]}

            위 취약점에 대한 조치방안을 다음과 같은 형식으로 요약해줘.
            이때 버전 업그레이드의 조치방안은 빼줘 그리고 조치방안은 5개 이하로 알려줘

            [조치 방안]
            1. ~~~~
            2. ~~~~
            3. ~~~~
            4. ~~~~
            5. ~~~~
        """

        plan_response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "You are an information security expert who speaks Korean."},
                {"role": "user", "content": plan_content},
            ]
        )
        
        return plan_response['choices'][0]['message']['content'].strip()
    
    def translate_vulnerability_description(cve_description):
        translation_request_content = f"""
            {cve_description}

            취약점 설명에 대해서 한국어로 번역해줘.
            이때 전문용어는 번역하지 말고 그대로 사용해줘.
        """
        
        translation_response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "You are an information security expert who speaks Korean."},
                {"role": "user", "content": translation_request_content},
            ]
        )
        
        return translation_response['choices'][0]['message']['content'].strip()
    
    def get_namespace_pattern(cve_id):
        if cve_id.startswith("GHSA"):
            return "github:%"
        elif cve_id.startswith("CVE"):
            return "nvd:%"
        else:
            return None
        
    def vunlerability_db_parsing(cve_id):
        namespace_pattern = get_namespace_pattern(cve_id)
        if namespace_pattern is None:
            return {"error": "지원하지 않는 취약점 ID 형식입니다."}, 400
        
        cursor = sqlite_client.cursor()
        cursor.execute("""
                SELECT id, description, cvss, severity
                FROM vulnerability_metadata
                WHERE id = ? AND namespace LIKE ?
            """, 
            (cve_id, namespace_pattern)
        )
        cve_info = cursor.fetchone()
        cursor.close()
        
        return cve_info
    
    @api.route('/report/<cve_id>')
    class singleVulnerabilityMitigation(Resource):
        @api.doc(
            responses={200: "Success", 404: "not found"},
            description="ChatGPT에 취약점 정보를 바탕으로 조치 방안 요청"
        )
        def get(self, cve_id): 
            cve_info = vunlerability_db_parsing(cve_id)

            if not cve_info:
                return {"error": "CVE 정보를 찾을 수 없습니다."}, 404

            mitigation_plan = get_cve_mitigation_plan(cve_info)
            translated_description = translate_vulnerability_description(cve_info[1])
            
            return {
                "response": {
                    "id": cve_info[0],
                    "description": translated_description,
                    "severity": cve_info[3],
                    "CVSS_info": cve_info[2],
                    "mitigation_plan": mitigation_plan
                }
            }, 200
    
    parser = reqparse.RequestParser()
    parser.add_argument('resultID', type=str, required=True, help='Result ID of the scanned SBOM file', location='args')
    
    @api.route('/report/all')
    class multiVulnerabilityMitigation(Resource):
        def cve_data_processing(self, cve_id):
            cve_info = vunlerability_db_parsing(cve_id)
            if not cve_info:
                return "CVE 정보가 없습니다."
            
            mitigation_plan = get_cve_mitigation_plan(cve_info)
            translated_description = translate_vulnerability_description(cve_info[1])

            return {
                "id": cve_info[0],
                "description": translated_description,
                "severity": cve_info[3],
                "CVSS_info": cve_info[2],
                "mitigation_plan": mitigation_plan
            }
            
        def mongoDB_data_processing(self, vuln_data):
            results = {}
            for doc in vuln_data:
                for match in doc["matches"]:
                    package_name = match["artifact"]["name"]
                    package_type = match["artifact"]["type"]
                    vuln_id = match["vulnerability"]["id"]
                    
                    if package_name not in results:
                        results[package_name] = {
                            "type": package_type,
                            "vulnerability": {}
                        }

                    results[package_name]["vulnerability"][vuln_id] = self.cve_data_processing(vuln_id)
                    
            return results
        
        @api.doc(
            responses={200: "Success", 404: "not found"},
            params={"resultID": {"description": "Result ID", "in": "query", "type": "string"}},
            description="ChatGPT에 CVE 정보를 바탕으로 조치 방안 요청"
        )
        def get(self): 
            args = parser.parse_args()
            reuslt_id = args["resultID"]
            
            vuln_data = mongo_handler.db[f"{reuslt_id}"].find()
            results = self.mongoDB_data_processing(vuln_data)
            
            return results, 200
       
    @api.route('/report/file')
    class vulnerabilityReport(Resource):
        @api.doc(
            responses={
                200: "Success - Report generated and downloaded successfully",
                400: "Bad Request - Invalid request format",
                404: "Not Found - The requested CVE ID was not found",
                500: "Internal Server Error - Error occurred while generating the report"
            },
            body=api.model('ReportRequestModel', {  # 요청 본문 모델
                'response': fields.Nested(api.model('Response', {
                    'id': fields.String,
                    'description': fields.String,
                    'severity': fields.String,
                    'CVSS_info': fields.String,
                    'mitigation_plan': fields.String
                }), required=True)
            }),
            description="Generates a security report based on the provided CVE information in the JSON payload and returns it for download"
        )
        def post(self):
            json_data = request.get_json()  # JSON 요청 본문을 직접 받음
            response = json_data['response']  # 'response' 키에 해당하는 값
            
            cve_id = response['id']
            report_filename = f"{cve_id} Security Report.docx"
            report_filepath = os.path.join("/tmp", report_filename)  # 임시 디렉토리에 파일 저장

            # Create a Word document
            doc = Document()

            # Set the margins
            sections = doc.sections
            for section in sections:
                section.top_margin = Inches(0.5)
                section.bottom_margin = Inches(0.5)
                section.left_margin = Inches(0.5)
                section.right_margin = Inches(0.5)

            # Set the main title
            title = doc.add_heading(level=0)
            title_run = title.add_run(f"{cve_id} Security Report")
            title_run.font.size = Pt(24)  # Reset main title font size to 24px
            title.alignment = WD_ALIGN_PARAGRAPH.CENTER

            # Add content to the document
            for key, value in response.items():
                heading = doc.add_heading(key, level=1)
                heading.style.font.size = Pt(12)  # Set heading font size to 12px
                
                if key == "mitigation_plan":
                    # Remove the "[조치 방안]" text and any extra whitespace from the content
                    value = value.replace("[조치 방안]\n", "").strip().replace('[', '').replace(']', '')
                    paragraph = doc.add_paragraph(value)
                    paragraph.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.LEFT
                else:
                    paragraph = doc.add_paragraph(value)
                    paragraph.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY
                paragraph.style.font.size = Pt(10)  # Set paragraph font size to 10px

            # Save the modified document
            doc.save(report_filepath)
            
            @after_this_request
            def remove_file(response):
                try:
                    os.remove(report_filepath)
                except Exception as error:
                    app.logger.error("Error removing or closing downloaded file handle", error)
                return response

            # Return the file for download
            return send_file(report_filepath, as_attachment=True)
        
    return api