import os
import json
import logging
from pymongo import MongoClient
from pymongo.errors import ServerSelectionTimeoutError
from typing import Union, List, Dict
from pymongo import MongoClient
from datetime import datetime, timedelta


# Constants
MONGO_URL = "mongodb://localhost:27017"
DB_NAME = "CVE-Scout"
JSON_EXT = ".json"


class Mongo_Handler:
    """
    A class to handle the interaction with MongoDB. It has methods to parse directories of JSON files,
    read the JSON data, and insert or update the data in a MongoDB database.
    """

    def __init__(self, json_path: str):
        """
        Initialize a new instance of the Save_DB class.

        Parameters:
            json_path (str): The directory path where the JSON files are stored.

        Returns:
            None
        """
        # Create a logger for this file
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(logging.INFO)

        # Create the logging directory if it does not exist
        if not os.path.exists("log/DB_LOG"):
            os.makedirs("log/DB_LOG")

        # Create a file handler
        handler = logging.FileHandler(f"log/DB_LOG/db_handler_{datetime.now().strftime('%Y%m%d%H%M%S')}.log")
        handler.setLevel(logging.INFO)

        # Create a logging format
        formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s [in %(pathname)s:%(lineno)d]")
        handler.setFormatter(formatter)

        # Add the handlers to the logger
        self.logger.addHandler(handler)
        
        self.client = MongoClient(MONGO_URL)
        self.db = self.client[DB_NAME]
        self.json_path = json_path
        
        if not os.path.isdir(json_path):
            raise FileNotFoundError(f"The directory {json_path} does not exist.")
        try:
            self.client = MongoClient(MONGO_URL, serverSelectionTimeoutMS=5000)
            self.client.server_info()  # will throw an exception if cannot connect to db
        except ServerSelectionTimeoutError as err:
            logging.error("Could not connect to MongoDB: %s", err)
            raise

    def _parse_year_directory(self) -> List[str]:
        """
        Parse the year directories in the specified JSON path.

        Returns:
            List[str]: A list of directory paths.
        """
        year_directory_list = []
        for year_directory in os.listdir(self.json_path):        
            year_directory_path = os.path.join(self.json_path, year_directory)

            if not os.path.isdir(year_directory_path):
                self.logger.warning(f"{year_directory_path} is not a directory.")
                continue

            year_directory_list.append(year_directory_path)
            year_directory_list.sort()

        return year_directory_list

    def _parse_json_files(self, year_directory_path: str) -> List[str]:
        """
        Parse the JSON files in a given year directory.

        Parameters:
            year_directory_path (str): The directory path of a specific year.

        Returns:
            List[str]: A list of file paths for the JSON files.
        """
        year_json_file_list = []

        for filename in os.listdir(year_directory_path):
            if filename.endswith(JSON_EXT):
                file_path = os.path.join(year_directory_path, filename)

                if not os.path.isfile(file_path):
                    self.logger.warning(f"{file_path} is not a file.")
                    continue

                year_json_file_list.append(file_path)
                year_json_file_list.sort()

        return year_json_file_list

    def _read_json_file(self, file_path: str) -> Union[Dict, List[Dict]]:
        """
        Read a JSON file and return its contents as a dictionary or a list of dictionaries.

        Parameters:
            file_path (str): The path to the JSON file.

        Returns:
            Union[Dict, List[Dict]]: A dictionary or a list of dictionaries representing the JSON file's contents.
        """
        try:
            with open(file_path, "r") as file:
                data = json.load(file)
                
                if isinstance(data, list):
                    cve_number = file_path.split("/")[-1].split(".")[0]

                    for cve_info in data:
                        cve_info['cve'] = cve_number
        except FileNotFoundError:
            self.logger.error(f"File {file_path} not found.")
            raise
        except json.JSONDecodeError:
            self.logger.error(f"File {file_path} is not a valid JSON file.")
            raise
        
        return data

    def _insert_data(self, collection, data: Union[Dict, List[Dict]]) -> None:
        """
        Insert the given data into the specified collection.

        Parameters:
            collection (Collection): The MongoDB collection.
            data (Union[Dict, List[Dict]]): The data to insert.
        """
        if isinstance(data, list):
            collection.insert_many(data)
        else:
            collection.insert_one(data)

    def save(self, collection_name: str) -> None:
        """
        Save JSON data into a MongoDB collection. The method reads JSON files from the
        specified directory, then inserts the data into the collection.

        Parameters:
            collection_name (str): The name of the MongoDB collection to insert data into.

        Returns:
            None
        """
        collection = self.db[collection_name]
        
        for year_directory in self._parse_year_directory():
            json_list = self._parse_json_files(year_directory)

            for file_path in json_list:
                data = self._read_json_file(file_path)
                self._insert_data(collection, data)

                self.logger.info(f"Inserted data from {file_path} into {collection_name}")

    def _is_collection(self, collection_name:str) -> bool:
        collection_list = self.db.list_collection_names()
        
        for collection in collection_list:
            if collection == collection_name:
                return True
            
        return False
    
    def delete(self, collection_name:str) -> None:
        if self._is_collection(collection_name):
            self.db[collection_name].drop()
            
    def grype_save(self, collection_name:str, grype_result_file_path:str) -> bool:
        # grype 결과 파일 로드
        with open(grype_result_file_path, 'r') as file:
            data = json.load(file)

        # 3일 후에 만료되도록 설정
        expiry_date = datetime.utcnow() + timedelta(days=3)
        data['expiry'] = expiry_date

        # 데이터 저장
        collection = self.db[collection_name]
        collection.insert_one(data)

        # 3일 후에 자동 삭제되도록 TTL 인덱스 생성
        # 이 작업은 한 번만 수행해도 되므로, 컬렉션이 이 인덱스를 가지고 있지 않은 경우에만 실행
        if 'expiry_1' not in collection.index_information():
            collection.create_index([('expiry', 1)], expireAfterSeconds=259200)  # 3일 (3*24*60*60초)
            
        return True
    