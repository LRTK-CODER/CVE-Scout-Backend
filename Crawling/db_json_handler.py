"""
This script handles the saving and updating of JSON data into a MongoDB database.
It uses the pymongo library to interact with MongoDB and the standard json library
to parse the JSON files. The script is designed to work with a specific directory
structure where JSON files are organized into directories by year.
"""

import os
import json
import logging
from pymongo import MongoClient
from pymongo.errors import ServerSelectionTimeoutError
from typing import List, Dict

# Constants
MONGO_URL = "mongodb://localhost:27017"
DB_NAME = "CVE-Scout"
JSON_EXT = ".json"

# Set up logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)


class Save_DB:
    """
    A class to handle the interaction with MongoDB. It has methods to parse directories of JSON files,
    read the JSON data, and insert or update the data in a MongoDB database.
    """

    def __init__(self, json_path: str):
        """
        Initialize a new instance of the Save_DB class.

        Parameters:
            json_path (str): The directory path where the JSON files are stored.

        Returns:
            None
        """
        if not os.path.isdir(json_path):
            raise FileNotFoundError(f"The directory {json_path} does not exist.")
        try:
            self.client = MongoClient(MONGO_URL, serverSelectionTimeoutMS=5000)
            self.client.server_info()  # will throw an exception if cannot connect to db
        except ServerSelectionTimeoutError as err:
            logging.error("Could not connect to MongoDB: %s", err)
            raise

        self.client = MongoClient(MONGO_URL)
        self.db = self.client[DB_NAME]
        self.json_path = json_path

    def _parse_year_directory(self) -> List[str]:
        """
        Parse the year directories in the specified JSON path.

        Returns:
            List[str]: A list of directory paths.
        """
        year_directory_list = []
        for year_directory in os.listdir(self.json_path):
            year_directory_path = os.path.join(self.json_path, year_directory)

            if not os.path.isdir(year_directory_path):
                logging.warning(f"{year_directory_path} is not a directory.")
                continue

            year_directory_list.append(year_directory_path)
            year_directory_list.sort()

        return year_directory_list

    def _parse_json_files(self, year_directory_path: str) -> List[str]:
        """
        Parse the JSON files in a given year directory.

        Parameters:
            year_directory_path (str): The directory path of a specific year.

        Returns:
            List[str]: A list of file paths for the JSON files.
        """
        year_json_file_list = []

        for filename in os.listdir(year_directory_path):
            if filename.endswith(JSON_EXT):
                file_path = os.path.join(year_directory_path, filename)

                if not os.path.isfile(file_path):
                    logging.warning(f"{file_path} is not a file.")
                    continue

                year_json_file_list.append(file_path)
                year_json_file_list.sort()

        return year_json_file_list

    def _read_json_file(self, file_path: str) -> Dict:
        """
        Read a JSON file and return its contents as a dictionary.

        Parameters:
            file_path (str): The file path of the JSON file to read.

        Returns:
            Dict: The contents of the JSON file as a dictionary.
        """
        try:
            with open(file_path, "r") as file:
                data = json.load(file)
        except FileNotFoundError:
            logging.error(f"File {file_path} not found.")
            raise
        except json.JSONDecodeError:
            logging.error(f"File {file_path} is not a valid JSON file.")
            raise
        
        return data

    def _insert_data(self, collection, data: Dict) -> None:
        """
        Insert a dictionary of data into a MongoDB collection.

        Parameters:
            collection: The MongoDB collection to insert data into.
            data (Dict): The data to insert into the collection as a dictionary.

        Returns:
            None
        """
        collection.insert_one(data)

    def save(self, collection_name: str) -> None:
        """
        Save JSON data into a MongoDB collection. The method reads JSON files from the
        specified directory, then inserts the data into the collection.

        Parameters:
            collection_name (str): The name of the MongoDB collection to insert data into.

        Returns:
            None
        """
        collection = self.db[collection_name]

        for year_directory in self._parse_year_directory():
            json_list = self._parse_json_files(year_directory)

            for file_path in json_list:
                data = self._read_json_file(file_path)
                self._insert_data(collection, data)

                logging.info(f"Inserted data from {file_path} into {collection_name}")

    def update(self, collection_name: str, update_cve_ids: List[str]) -> None:
        """
        Update specific entries in a MongoDB collection with new data from JSON files.
        The method reads JSON files corresponding to the specified CVE IDs, then replaces
        the existing data in the collection with the new data.

        Parameters:
            collection_name (str): The name of the MongoDB collection to update.
            update_cve_ids (List[str]): A list of CVE IDs to update in the collection.

        Returns:
            None
        """
        collection = self.db[collection_name]

        for cve_id in update_cve_ids:
            year_directory_path = os.path.join(self.json_path, cve_id.split("-")[1])
            file_path = os.path.join(year_directory_path, cve_id + JSON_EXT)

            try:
                data = self._read_json_file(file_path)
            except FileNotFoundError:
                logging.warning(f"File {file_path} for CVE ID {cve_id} not found. Skipping update for this ID.")
                continue

            filter_query = {"cve.id": cve_id}
            collection.replace_one(filter_query, data)

            logging.info(f"Updated {cve_id} in {collection_name}")


if __name__ == "__main__":
    # JSON files are assumed to be in the "./jsons" directory
    db_handler = Save_DB("./jsons")

    # Testing the save method
    db_handler.save("test_collection")

    # Testing the update method with a list of CVE IDs
    # Assuming that "CVE-2017-0143.json", "CVE-2017-0144.json", "CVE-2017-0145.json" are present in the "json_files" directory
    update_cve_ids = ["CVE-2017-0143", "CVE-2017-0144", "CVE-2017-0145"]
    db_handler.update("test_collection", update_cve_ids)
