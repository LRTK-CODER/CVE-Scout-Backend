import os
import datetime
import json
import pytz
import requests
import time
import logging
from datetime import datetime, timedelta
from typing import Optional, Dict, Any, List


class NVD_CVE_Parser:
    """
    This class provides methods for fetching and saving CVE data from the NVD API.
    """
    def __init__(self, api_url: str, api_key: str):
        """
        Initializes the NVD_CVE_Parser with the provided API URL and key.
        
        Parameters:
        api_url (str): The URL of the NVD API.
        api_key (str): The key for accessing the NVD API.
        """
        self.api_url = api_url
        self.headers = {"apiKey": api_key}
        self.seoul_tz = pytz.timezone("Asia/Seoul")

        # Create the logging directory if it does not exist
        if not os.path.exists("log/NVD_LOG"):
            os.makedirs("log/NVD_LOG")

        # Configure the logger
        logging.basicConfig(
            filename=f"log/NVD_LOG/nvd_parser_{datetime.now().strftime('%Y%m%d%H%M%S')}.log",
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
        
    def _get_response(self, url: str, retry_count: int = 3) -> Optional[Dict[str, Any]]:
        """
        Sends a GET request to the provided URL and returns the response.
        
        Parameters:
        url (str): The URL to send the GET request to.
        retry_count (int, optional): The number of times to retry the request if it fails. Defaults to 3.
        
        Returns:
        Optional[Dict[str, Any]]: The response from the GET request, or None if the request fails.
        """
        if retry_count < 1:
            logging.warning("요청 재시도 횟수를 초과했습니다.")
            return None

        response = requests.get(url, headers=self.headers)

        if response.status_code == 403:
            logging.warning("API 요청이 너무 빠릅니다. 잠시 후 다시 시도합니다. 상태 코드: {response.status_code}")
            time.sleep(6)
            return self._get_response(url, retry_count - 1)  # 6초 후에 재시도

        elif response.status_code != 200:
            logging.error(f"API 요청에 실패했습니다. 상태 코드: {response.status_code}")
            print(response.text)
            return None

        try:
            return response.json()
        except json.JSONDecodeError:
            logging.error("API에서 반환한 응답이 JSON 형식이 아닙니다. 응답 내용:")
            logging.error(response.text)
            return None

    def fetch_cve_data(self, start_index: int, results_per_page: int) -> Optional[List[Dict[str, Any]]]:
        """
        Fetches CVE data from the NVD API.
        
        Parameters:
        start_index (int): The index of the first CVE data to fetch.
        results_per_page (int): The number of CVE data to fetch per page.
        
        Returns:
        Optional[List[Dict[str, Any]]]: A list of CVE data, or None if the fetch fails.
        """
        url = f"{self.api_url}/?resultsPerPage={results_per_page}&startIndex={start_index}"
        logging.info(f"Sending request to {url}")
        response_json = self._get_response(url)

        if response_json is None:
            return None

        cve_data = response_json["vulnerabilities"]

        self.save_cve_data(cve_data)
        
        return cve_data
    
    def fetch_modified_cve_data(self, days: int = 0) -> Optional[List[str]]:
        """
        Fetches the IDs of CVEs that were modified within the past number of days.
        
        Parameters:
        days (int, optional): The number of past days to fetch modified CVEs from. Defaults to 0.
        
        Returns:
        Optional[List[str]]: A list of modified CVE IDs, or None if the fetch fails.
        """
        now = datetime.now(self.seoul_tz) - timedelta(days)

        start_of_yesterday = now.replace(hour=0, minute=0, second=0, microsecond=0)
        end_of_yesterday = start_of_yesterday + timedelta(days=1)

        start_date = start_of_yesterday.isoformat().replace("+", "%2B")
        end_date = end_of_yesterday.isoformat().replace("+", "%2B")

        url = f"{self.api_url}?lastModStartDate={start_date}&lastModEndDate={end_date}"

        response_json = self._get_response(url)

        if response_json is None:
            return None

        cve_ids = []

        cve_data = response_json["vulnerabilities"]
        self.save_cve_data(cve_data)

        for cve_item in cve_data:
            cve_id = cve_item["cve"]["id"]
            cve_ids.append(cve_id)
    
        return cve_ids
    
    def fetch_cve_data_with_keyword(
        self,
        start_index: int,
        results_per_page: int,
        keyword: str,
        exact_match: bool = False,
    ) -> Optional[List[str]]:
        """
        Fetches the IDs of CVEs that contain the provided keyword.
        
        Parameters:
        start_index (int): The index of the first CVE data to fetch.
        results_per_page (int): The number of CVE data to fetch per page.
        keyword (str): The keyword to search for in the CVE data.
        exact_match (bool, optional): Whether to return only CVEs that exactly match the keyword. Defaults to False.
        
        Returns:
        Optional[List[str]]: A list of CVE IDs that contain the keyword, or None if the fetch fails.
        """
        if keyword == "":
            raise ValueError(
                "Warning: No keyword provided. Please specify a keyword and try again."
            )

        keyword_encoded = requests.utils.quote(keyword)
        url = f"{self.api_url}/?keywordSearch={keyword_encoded}&resultsPerPage={results_per_page}&startIndex={start_index}"

        if exact_match:
            url += "&keywordExactMatch"

        response_json = self._get_response(url)

        if response_json is None:
            return None

        cve_ids = []

        cve_data = response_json["vulnerabilities"]
        for cve_item in cve_data:
            cve_id = cve_item["cve"]["id"]
            cve_ids.append(cve_id)
     
        return cve_ids

    def is_fetch_completed(self, data: Optional[List[Dict[str, Any]]], expected_length: int) -> bool:
        """
        Checks whether the fetch of CVE data is completed.
        
        Parameters:
        data (Optional[List[Dict[str, Any]]]): The fetched CVE data.
        expected_length (int): The expected length of the fetched CVE data.
        
        Returns:
        bool: True if the fetch is completed, False otherwise.
        """
        if data is None or len(data) < expected_length:
            return True

        return False

    def _year_division(self, cve_id: str) -> str:
        """
        Extracts the year from a CVE ID.
        
        Parameters:
        cve_id (str): The CVE ID to extract the year from.
        
        Returns:
        str: The year extracted from the CVE ID.
        """
        return cve_id.split("-")[1]

    def _create_directory(self, year: str) -> None:
        """
        Creates a directory for the provided year if it does not exist.
        
        Parameters:
        year (str): The year to create the directory for.
        """
        if not os.path.exists(f"./jsons/{year}"):
            os.makedirs(f"./jsons/{year}")

    def save_cve_data(self, cve_data: list) -> None:
        """
        Saves the provided CVE data.
        
        Parameters:
        cve_data (list): The CVE data to save.
        """
        for cve_item in cve_data:
            cve_id = cve_item["cve"]["id"]
            logging.info(f"Parsing information for {cve_id}")

            year = self._year_division(cve_id)
            self._create_directory(year)
            
            self.save_json(cve_item, year)
            
    def save_json(self, cve_item: dict, year: str) -> None:
        """
        Saves a CVE item as a JSON file in the directory for the provided year.
        
        Parameters:
        cve_item (dict): The CVE item to save.
        year (str): The year of the CVE item.
        """
        cve_id = cve_item["cve"]["id"]

        file_path = f"./jsons/{year}"

        try:
            with open(f"{file_path}/{cve_id}.json", "w") as out_file:
                json.dump(cve_item, out_file, indent=4)
            logging.info(f"Successfully saved {cve_id}.json")
        except Exception as e:
            logging.error(f"Failed to save {cve_id}.json due to {str(e)}")


if __name__ == "__main__":
    NVD_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0/"

    # API 키를 저장하고 있는 파일에서 API 키를 읽어옵니다.
    with open("api_key", "r") as file:
        API_KEY = file.read().strip()

    nvd = NVD_CVE_Parser(NVD_API_URL, API_KEY)

    start_index = 0
    results_per_page = 2000

    request_count = 0

    # Fetching all data
    while True:
        cve_data = nvd.fetch_cve_data(start_index, results_per_page)

        if nvd.is_fetch_completed(cve_data, results_per_page):
            print("모든 정보를 가져왔습니다.")
            break

        start_index += results_per_page

    # Fetching modified data
    # print(nvd.fetch_modified_cve_data(days=1)
    
    # Fetching data with keyword
    # keyword = "Microsoft Office"
    # keyword_cve_lsit = []
    # while True:
    #     cve_ids = nvd.fetch_cve_data_with_keyword(
    #         start_index,
    #         results_per_page,
    #         keyword,
    #         exact_match=True
    #     )
    #     if cve_ids is None or len(cve_ids) == 0:
    #         break
    #     keyword_cve_lsit.extend(cve_ids)
    #     start_index += results_per_page
    # print(keyword_cve_lsit)
    